> * 原文地址：[The RedMonk Programming Language Rankings: January 2021](https://redmonk.com/sogrady/2021/03/01/language-rankings-1-21/)
> * 原文作者：[RedMonk](https://redmonk.com/sogrady/2021/03/01/language-rankings-1-21/)
> * 译文出自：[掘金翻译计划](https://github.com/xitu/gold-miner)
> * 本文永久链接：[https://github.com/xitu/gold-miner/blob/master/article/2021/The-RedMonk-Programming-Language-Rankings-January-2021.md](https://github.com/xitu/gold-miner/blob/master/article/2021/The-RedMonk-Programming-Language-Rankings-January-2021.md)
> * 译者：[霜羽 Hoarfroster](https://github.com/PassionPenguin)
> * 校对者：

This iteration of the RedMonk Programming Language Rankings is brought to you by MongoDB. From the edge to the cloud, MongoDB enables you to work with data as code – in any language – so you can build and ship applications faster. If you are a Python, .NET, Java, or Javascript developer, get started now with [MongoDB University](https://university.mongodb.com/learning_paths/developer).

On the one hand, this quarter’s rankings might seem late given that it’s March, not January. On the other, given that it is technically still March 2020, one could argue that these rankings are in fact early. Late or early, however, the rankings are now complete and available for your perusal.

As always, these are a continuation of the work originally performed by Drew Conway and John Myles White late in [2010](http://www.dataists.com/2010/12/ranking-the-popularity-of-programming-langauges/). While the specific means of collection has changed, the basic process remains the same: we extract language rankings from GitHub and Stack Overflow, and combine them for a ranking that attempts to reflect both code (GitHub) and discussion (Stack Overflow) traction. The idea is not to offer a statistically valid representation of current usage, but rather to correlate language discussion and usage in an effort to extract insights into potential future adoption trends.

# Our Current Process

The data source used for the GitHub portion of the analysis is the GitHub Archive. We query languages by pull request in a manner similar to the one GitHub used to assemble the State of the Octoverse. Our query is designed to be as comparable as possible to the previous process.

- Language is based on the base repository language. While this continues to have the caveats outlined below, it does have the benefit of cohesion with our previous methodology.
- We exclude forked repos.
- We use the aggregated history to determine ranking (though based on the table structure changes this can no longer be accomplished via a single query.)

For Stack Overflow, we simply collect the required metrics using their useful data explorer tool.

With that description out of the way, please keep in mind the other usual caveats.

- To be included in this analysis, a language must be observable within both GitHub and Stack Overflow.
- No claims are made here that these rankings are representative of general usage more broadly. They are nothing more or less than an examination of the correlation between two populations we believe to be predictive of future use, hence their value.
- There are many potential communities that could be surveyed for this analysis. GitHub and Stack Overflow are used here first because of their size and second because of their public exposure of the data necessary for the analysis. We encourage, however, interested parties to perform their own analyses using other sources.
- All numerical rankings should be taken with a grain of salt. We rank by numbers here strictly for the sake of interest. In general, the numerical ranking is substantially less relevant than the language’s tier or grouping. In many cases, one spot on the list is not distinguishable from the next. The separation between language tiers on the plot, however, is generally representative of substantial differences in relative popularity.
- In addition, the further down the rankings one goes, the less data available to rank languages by. Beyond the top tiers of languages, depending on the snapshot, the amount of data to assess is minute, and the actual placement of languages becomes less reliable the further down the list one proceeds.
- Languages that have communities based outside of Stack Overflow such as Mathematica will be under-represented on that axis. It is not possible to scale a process that measures one hundred different community sites, both because many do not have public metrics available and because measuring different community sites against one another is not statistically valid.

With that, here is the first quarter plot for 2021.

(*Click to embiggen*)

![https://redmonk.com/sogrady/files/2021/03/lang.rank_.0121.wm_-1024x805.png](https://redmonk.com/sogrady/files/2021/03/lang.rank_.0121.wm_-1024x805.png)

Besides the above plot, which can be difficult to parse even at full size, we offer the following numerical rankings. As will be observed, this run produced several ties which are reflected below (they are listed out here alphabetically rather than consolidated as ties because the latter approach led to misunderstandings).

1 JavaScript2 Python3 Java4 PHP5 C#5 C++5 CSS8 TypeScript9 Ruby10 C11 Swift12 R13 Objective-C14 Shell14 Scala16 Go17 PowerShell18 Kotlin19 Rust19 Perl

In a contrast to our last run that was fairly static within the Top 20 – not unusual for accretive metrics – this quarter’s run featured quite a bit of change and movement. Fully half of the Top 20 experienced a degree of movement, which is very unusual. It’s difficult to attribute this definitively to any higher level macro trends, but the data is consistent with an industry that picked the pace back up in the last two quarters of the year after the initial chaos of lockdowns and so on gave way to livable if extremely suboptimal new routines.

Not only is there change, however, it’s notable and, if sustained, significant change as we’ll get into shortly. One lack of change that is worth surfacing is Python’s number two spot. Java was extremely hot on Python’s heels – and was in fact closer to the number one ranking than to PHP behind it – but Python’s ability to defend its new high ranking is notable.

With that preamble, here are the most important takeaways from this edition of the rankings. The numbers in parentheses are the net change in a language’s ranking from our last run.

- **JavaScript** (0): Given that the setup for this analysis was about change, it might seem counterintuitive to lead off with a discussion about JavaScript which did not move in these rankings. But it is worth noting just how robust JavaScript’s performance remains. In spite of all of the competition from up and coming languages, all the discussion of fragmentation and even criticisms of JavaScript the language itself, it remains remarkably popular. Since our first quarter run of January of 2018, for example, JavaScript pull requests are up 453%. They were up 96% just from the last quarter, and that was on an already massive base of commits. Simply put, JavaScript remains – its detractors notwithstanding – a force of nature like no other within the industry, and there are no indications in the data that this is likely to change any time soon.
- **TypeScript** (1): Speaking of JavaScript’s performance, TypeScript’s ascent up our rankings continues. This is impressive on its own rights; the only language in recent memory to penetrate the Top 10 was Swift, but that was for a single quarter and it quickly bounced back out and has remained relatively static since 2018 in 11th place. The initial question facing TypeScript was whether it would be able to hold on. The more appropriate question now is what the language’s ultimate ceiling might be. TypeScript moved up for the sixth of its latest eight quarterly rankings, and its popularity is evident when one looks around the industry. Just as interesting as the growth, however, is the language at whose expense the growth comes from.
- **Ruby** (-2): Ruby, as discussed in this space previously, has been in a long term downward if gentle trajectory. This quarter’s run, however, raises questions as to how gentle it will continue to be. When we started doing these rankings in 2012, Ruby was the fifth most popular language we ranked, and for about five years it was able to maintain that status. Since 2016, however, Ruby has been gradually slipping, and this quarter it was passed by both CSS (yes, we know many of you don’t believe it should be ranked) and the aforementioned TypeScript. Ruby has made an effort in recent years to address some of its performance issues, but setting aside that there are questions about what was claimed versus what has been achieved, the focus on performance does not appear to have changed the language’s fortunes as measured by our rankings in any material fashion. To be clear, there are dozens if not hundreds of languages that would happily change places with the ninth ranked language on
  these rankings, but it’s less the actual placing here than the trajectory that should concern Ruby advocates and users. It’s a lovely language with a beautiful syntax, but that has not been enough in a highly competitive language marketplace.
- **Go** (-1): Like Ruby, Go’s ranking is less of a concern than its overall trajectory. After an initial period of rapid growth, peaking with its #14 ranking in 2018, Go has been a language that is at best static and arguably on a decline path. As has been discussed previously, some of this is explained by Go’s much more narrow addressable market relative to some of the other languages on this list. It also has not helped Go that Java, a primary competitor for back end application composition, has remained a vital and highly used language instead of fading away after so many years of service. But whether it’s static or in decline, if Go has ambitions to be a true industry force, some change in its path and structure is probably necessary.
- **R** (1): We’ve written often in this space of the fortunes of R, a staple of academia among other communities but a language that excels within a single domain – analysis – and is essentially not relevant outside of that domain. It has been one of several languages used to address a simple question: what might the fortunes of a specialized language be in today’s fragmented world, and how high – or low – could it be driven? Typically, specialized languages have been outperformed by more versatile ones – think Java versus Go as mentioned above. R, however, has been something of an exception to this rule. While its growth has never been meteoric or linear, the language that was rated 17 when we began these rankings many years ago placed 12th in this analysis. That is interesting; more so was the fact that it passed Objective C (-2) to get there. Objective C, a long time Top 10 stalwart, has been on a downward trajectory since the introduction of an intended replacement, Swift. It
  still surprising, however, to see a language focused on statistical analysis place ahead of the language with which the vast majority of pre-2014 iOS applications were written in.
- **Kotlin** (1) / **Rust** (1): Kotlin and Rust have no real relationship with one another other than the fact that they have some functional overlap. Kotlin is a JVM-based language with a modern syntax that can be freely intermingled with Java, a language with a good backend story but that is also a first class citizen on Android. Rust is a security-minded language heavily used by organizations like Mozilla but often thought of as an alternative to Go as well. Speaking of Mozilla, they transferred all of their Rust trademark and infrastructure assets to the new Rust Foundation, a steward for the language also backed by AWS, Google, Huawei and Microsoft. Kotlin and Rust have one other thing in common, however, which is that their popularity with developers bumped them up one spot each in this quarters rankings – Rust to 19, Kotlin to 18. To date Kotlin has been the hare to Rust’s tortoise, but it will be interesting to see if Rust’s new dedicated foundation alters that dynamic at
  all.
- **Dart** (3): Less than three years ago Dart was languishing in the thirties, having shown minimal traction by the proxies for developer interest and activity that we use. Two years after the introduction of the Flutter framework, however, Dart is up another three spots to sit just outside of our Top 20 at 21. This jump comes two quarters after Dart had seemingly stalled – along with Kotlin – raising questions of whether it had peaked. This quarter’s run suggests that the answer to that question is no. It seems clear that Flutter has had a material impact on the language’s popularity, and clearly its ability to compile to the most popular programming in the world is likewise not hurting it. While it’s extremely difficult to merely get to the #21 spot on our rankings – as Rust, among others, can attest – with this quarter’s resumption of its upwards trajectory, we can turn our attention back to watching whether Dart can break into the Top 20, and if so what it might displace along
  the way.

> 如果发现译文存在错误或其他需要改进的地方，欢迎到 [掘金翻译计划](https://github.com/xitu/gold-miner) 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 **本文永久链接** 即为本文在 GitHub 上的 MarkDown 链接。

---

> [掘金翻译计划](https://github.com/xitu/gold-miner) 是一个翻译优质互联网技术文章的社区，文章来源为 [掘金](https://juejin.im) 上的英文分享文章。内容覆盖 [Android](https://github.com/xitu/gold-miner#android)、[iOS](https://github.com/xitu/gold-miner#ios)、[前端](https://github.com/xitu/gold-miner#前端)、[后端](https://github.com/xitu/gold-miner#后端)、[区块链](https://github.com/xitu/gold-miner#区块链)、[产品](https://github.com/xitu/gold-miner#产品)、[设计](https://github.com/xitu/gold-miner#设计)、[人工智能](https://github.com/xitu/gold-miner#人工智能)等领域，想要查看更多优质译文请持续关注 [掘金翻译计划](https://github.com/xitu/gold-miner)、[官方微博](http://weibo.com/juejinfanyi)、[知乎专栏](https://zhuanlan.zhihu.com/juejinfanyi)。
