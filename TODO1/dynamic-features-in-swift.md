> * ÂéüÊñáÂú∞ÂùÄÔºö[Dynamic Features in Swift](https://www.raywenderlich.com/5743-dynamic-features-in-swift)
> * ÂéüÊñá‰ΩúËÄÖÔºö[Mike Finney](https://www.raywenderlich.com/u/finneycanhelp)
> * ËØëÊñáÂá∫Ëá™Ôºö[ÊéòÈáëÁøªËØëËÆ°Âàí](https://github.com/xitu/gold-miner)
> * Êú¨ÊñáÊ∞∏‰πÖÈìæÊé•Ôºö[https://github.com/xitu/gold-miner/blob/master/TODO1/dynamic-features-in-swift.md](https://github.com/xitu/gold-miner/blob/master/TODO1/dynamic-features-in-swift.md)
> * ËØëËÄÖÔºö
> * Ê†°ÂØπËÄÖÔºö

# Dynamic Features in Swift

> In this tutorial, you‚Äôll learn to use dynamic features in Swift to write clean code, create code clarity and resolve unforeseen issues quickly.

As a busy Swift developer, you have needs that are specific to your world yet common to all. You want to create clean-looking code, learn what‚Äôs going on in your code at a glance and resolve unforeseen issues quickly.

This tutorial ties together the dynamic and flexible parts of Swift to meet those needs. Using the latest Swift technology, you‚Äôll learn how to customize output to your console, hook into third-party object state changes, and use some sweet syntactical sugar to write cleaner code.

Specifically, you will learn about:

*   `Mirror`
*   `CustomDebugStringConvertible`
*   Key-value Observing with Key Paths
*   Dynamic Member Lookup
*   Related technologies

Most of all, you‚Äôll have a doggone good time!

This tutorial requires Swift 4.2 or later. Until Xcode 10 is released, you must [download the latest Xcode 10 Beta](https://developer.apple.com/download/) or install the latest [Swift 4.2 snapshot](https://swift.org/download/#snapshots).

Also, you must have an understanding of basic Swift types. The [Getting to Know Enums, Structs and Classes in Swift](https://www.raywenderlich.com/119881/enums-structs-and-classes-in-swift) tutorial is a great place to start. Although not strictly required, you may want to look into [Implementing Custom Subscripts in Swift](https://www.raywenderlich.com/123102/implementing-custom-subscripts-swift) as well.

## Getting Started

Before doing anything, download the starter and final projects by clicking on the _Download Materials_ button at the top or the bottom of the tutorial. Unzip the downloaded file.

You‚Äôll be happy to know that all the code you need to let you focus on learning the dynamic features of Swift is already written for you! Like walking with a friendly guide dog, this tutorial will guide you through everything in the starter code.

![](https://koenig-media.raywenderlich.com/uploads/2018/06/smiling_dog_small.jpg)

Happy Dog

In the starter code directory named _DynamicFeaturesInSwift-Starter_, you‚Äôll see three playground pages: _DogMirror_, _DogCatcher_ and _KennelsKeyPath_. The playground is set to run on macOS. This tutorial is platform-agnostic and only focuses on the Swift language.

## Reflecting on Mirror and Debug Output

Whether you‚Äôre tracking down an issue or just exploring running code, uncluttered information in the console makes all the difference. Swift offers many ways of customizing console output and capturing crucial events. For customizing output, it doesn‚Äôt get any deeper than Mirror. Swift offers more power than the strongest sled dog to pull you out of the icy cold land of confusion!

![](https://koenig-media.raywenderlich.com/uploads/2018/06/siberian_husky_small.jpg)

Siberian Husky Sled Dogs

Before learning more about `Mirror`, you‚Äôll first write some customized console output for a type. This will help you more clearly see what‚Äôs going on.

### CustomDebugStringConvertible

Open _DynamicFeaturesInSwift.playground_ in Xcode and go to the **DogMirror** page.

In honor of all those cute little dogs that get lost, caught by a dog catcher and then reunited with their owners, this page has a `Dog` class and `DogCatcherNet` class. Focus on the `DogCatcherNet` first.

Since the lost doggies out there must be caught and reunited with their owners, dog catchers must be supported. The code you write in the following project will help dog catchers evaluate the quality of nets.

In the playground, look at the following:

```
enum CustomerReviewStars { case one, two, three, four, five }
```

```
class DogCatcherNet {
  let customerReviewStars: CustomerReviewStars
  let weightInPounds: Double
  // ‚òÜ Add Optional called dog of type Dog here

  init(stars: CustomerReviewStars, weight: Double) {
    customerReviewStars = stars
    weightInPounds = weight
  }
}

```

```
let net = DogCatcherNet(stars: .two, weight: 2.6)
debugPrint("Printing a net: \(net)")
debugPrint("Printing a date: \(Date())")
print()

```

The `DogCatcherNet` has two properties: `customerReviewStars` and its `weightInPounds`. Customer review stars reflect the customers‚Äô feelings about the net product. The weight in pounds tells the dog catchers what burden they will experience lugging a net around.

Run the playground. The first two lines you should see are similar to the following:

```
"Printing a net: __lldb_expr_13.DogCatcherNet"
"Printing a date: 2018-06-19 22:11:29 +0000"
```

As you can see, the debug output in the console prints something related to a net and a date. Bless its heart; the output from the code looks like it was made by a robotic pet. This pet tried hard, but it needs help from us humans. As you can see, it‚Äôs printing out extra information such as ‚Äú__lldb_expr_.‚Äù Printing out the date provides something more useful. It‚Äôs up in the air as to whether or not this is enough to help you track down a problem that‚Äôs been dogging you.

To increase your chances of success, you need to apply some console output customization basics using `CustomDebugStringConvertible` magic. In the playground, add the following code right under _‚òÜ Add Conformance to CustomDebugStringConvertible for DogCatcherNet here_:

```
extension DogCatcherNet: CustomDebugStringConvertible {
  var debugDescription: String {
    return "DogCatcherNet(Review Stars: \(customerReviewStars),"
      + " Weight: \(weightInPounds))"
  }
}

```

For something small like `DogCatcherNet`, a type can conform to `CustomDebugStringConvertible` and provide its own debug description using the `debugDescription` property.

Run the playground. Except for a date value difference, the first two lines should include:

```
"Printing a net: DogCatcherNet(Review Stars: two, Weight: 2.6)"
"Printing a date: 2018-06-19 22:10:31 +0000"
```

For a larger type with many properties, this approach comes with the cost of explicit boilerplate to type. That‚Äôs not a problem for one with dogged determination. If short on time, there are other options such as `dump`.

### Dump

How to avoid needing to add boilerplate code manually? One solution is to use `dump`. `dump` is a generic function that prints out all the names and values of a type‚Äôs properties.

The playground already contains calls that dump out the net and `Date`. The code looks like this:

```
dump(net)
print()

dump(Date())
print()
```

Run the playground. The console output looks something like:

```
‚ñø DogCatcherNet(Review Stars: two, Weight: 2.6) #0
  - customerReviewStars: __lldb_expr_3.CustomerReviewStars.two
  - weightInPounds: 2.6

‚ñø 2018-06-26 17:35:46 +0000
  - timeIntervalSinceReferenceDate: 551727346.52924
```

Due to the work you‚Äôve done so far with `CustomDebugStringConvertible`, the `DogCatcherNet` looks better than it otherwise would. The output contains:

```
DogCatcherNet(Review Stars: two, Weight: 2.6)
```

`dump` also spits out each property automatically. Great! It‚Äôs time to make those properties more readable by using Swift‚Äôs `Mirror`.

### Swift Mirror

![](https://koenig-media.raywenderlich.com/uploads/2018/06/mirror_dog_small.jpg)

Mirror, mirror, on the wall. Who‚Äôs the fairest dog of them all?

`Mirror` lets you display values of any type instance through the playground or the debugger at runtime. In short, `Mirror`‚Äòs power is introspection. Introspection is a subset of [reflection](https://developer.apple.com/documentation/swift/swift_standard_library/debugging_and_reflection).

### Creating a Mirror-Powered Dog Log

It‚Äôs time to create a Mirror-powered dog log. To help with debugging, it‚Äôs ideal to display the values of the net to the console through a log function with custom output complete with emoticons. The log function should be able to handle any item you pass it.

### Creating a Mirror

It‚Äôs time to create a log function that uses a mirror. To start, add the following code right under _‚òÜ Create log function here_:

```
func log(itemToMirror: Any) {
  let mirror = Mirror(reflecting: itemToMirror)
  debugPrint("Type: üê∂ \(type(of: itemToMirror)) üê∂ ")
}
```

This creates the mirror for the passed-in item. A mirror lets you iterate over the parts of an instance.

Add the following code to the end of the `log(itemToMirror:)`:

```
for case let (label?, value) in mirror.children {
  debugPrint("‚≠ê \(label): \(value) ‚≠ê")
}
```

This accesses the `children` property of the mirror, gets each label-value pair, then prints them out to the console. The label-value pair is type-aliased as `Mirror.Child`. For a `DogCatcherNet` instance, the code iterates over the properties of a net object.

To clarify, a child of the instance being inspected has nothing to do with a superclass or subclass hierarchy. The children accessible through a mirror are just the parts of the instance being inspected.

Now, it‚Äôs time to call your new log method. Add the following code right under _‚òÜ Log out the net and a Date object here_:

```
log(itemToMirror: net)
log(itemToMirror: Date())
```

Run the playground. You‚Äôll see at the bottom of the console output some doggone great output:

```
"Type: üê∂ DogCatcherNet üê∂ "
"‚≠ê customerReviewStars: two ‚≠ê"
"‚≠ê weightInPounds: 2.6 ‚≠ê"
"Type: üê∂ Date üê∂ "
"‚≠ê timeIntervalSinceReferenceDate: 551150080.774974 ‚≠ê"
```

This shows all the properties‚Äô names and values. The names appear as they do in your code. For example, `customerReviewStars` is literally how the property name is spelled in code.

### CustomReflectable

What if you wanted more of a dog and pony show in which the property names are displayed more clearly as well? What if you didn‚Äôt want some of the properties displayed? What if you wanted items displayed that are not technically part of the type? You‚Äôd use `CustomReflectable`.

`CustomReflectable` provides the hook with which you can specify what parts of a type instance are shown by using a custom `Mirror`. To conform to `CustomReflectable`, a type must define the `customMirror` property.

After speaking with several dog catcher programmers, you‚Äôve discovered that spitting out the `weightInPounds` of the net has not helped with debugging. However, the `customerReviewStars` information is extremely helpful and they‚Äôd like the label for `customerReviewStars` to appear as ‚ÄúCustomer Review Stars.‚Äù Now, it‚Äôs time to make `DogCatcherNet` conform to `CustomReflectable`.

Add the following code right under _‚òÜ Add Conformance to CustomReflectable for DogCatcherNet here_:

```
extension DogCatcherNet: CustomReflectable {
  public var customMirror: Mirror {
    return Mirror(DogCatcherNet.self,
                  children: ["Customer Review Stars": customerReviewStars,
                            ],
                  displayStyle: .class, ancestorRepresentation: .generated)
  }
}
```

Run the playground and see the following output:

```
"Type: üê∂ DogCatcherNet üê∂ "
"‚≠ê Customer Review Stars: two ‚≠ê"
```

_Where‚Äôs the Dog?_  
The whole point of the net is to handle having a dog. When the net is populated with a dog, there must be a way to pull out information about the dog in the net. Specifically, you need the dog‚Äôs name and age.

The playground page already has a `Dog` class. It‚Äôs time to connect `Dog` with `DogCatcherNet`. In the spot labeled as _‚òÜ Add Optional called dog of type Dog here_, add the following property to `DogCatcherNet`:

```
var dog: Dog?
```

With the dog property added to the `DogCatcherNet`, it‚Äôs time to add the dog to the `customMirror` for the `DogCatcherNet`. Add the following dictionary entries right after the line `children: ["Customer Review Stars": customerReviewStars,`:

```
"dog": dog ?? "",
"Dog name": dog?.name ?? "No name"
```

This will output the dog using its default debug description and dog‚Äôs name, respectively labeled ‚Äúdog‚Äù and ‚ÄúDog name.‚Äù

Time to gently put a dog into the net. Right under _‚òÜ Uncomment assigning the dog_, uncomment that line so the cute little dog is put into the net:

```
net.dog = Dog() // ‚òÜ Uncomment out assigning the dog
```

Run the playground and see the following:

```
"Type: üê∂ DogCatcherNet üê∂ "
"‚≠ê Customer Review Stars: two ‚≠ê"
"‚≠ê dog: __lldb_expr_23.Dog ‚≠ê"
"‚≠ê Dog name: Abby ‚≠ê"
```

_Mirror Convenience_  
It‚Äôs pretty nice to be able to see everything. However, there are those times when you just want to pluck out a part from a mirror. To do that, you use [`descendant(_:_:)`](https://developer.apple.com/documentation/swift/mirror/1540759-descendant). Add the following code to the end of the playground page to create a mirror and use `descendant(_:_:)` to pluck out the name and age:

```
let netMirror = Mirror(reflecting: net)

print ("The dog in the net is \(netMirror.descendant("dog", "name") ?? "nonexistent")")
print ("The age of the dog is \(netMirror.descendant("dog", "age") ?? "nonexistent")")
```

Run the playground and see at the bottom of the console output:

```
The dog in the net is Bernie
The age of the dog is 2
```

That‚Äôs doggone dynamic introspection there. It can be quite useful for debugging your own types! Having deeply explored `Mirror`, you‚Äôre done with _DogMirror.xcplaygroundpage_.

### Wrapping Up Mirror and Debug Output

There are many ways to track, like a bloodhound, what‚Äôs going on in a program. `CustomDebugStringConvertible`, `dump` and `Mirror` let you see more clearly what you are hunting for. Swift‚Äôs introspection power is highly useful ‚Äî especially as you start building bigger and more complex applications!

## Key Paths

On the subject of tracking what‚Äôs going on in a program, Swift has something wonderful called key paths. For capturing an event such as when a value has changed in a third-party library object, look `to KeyPath`‚Äòs `observe` for help.

In Swift, key paths are strongly typed paths whose types are checked at compile time. In Objective-C, they were only strings. The tutorial [What‚Äôs New in Swift 4?](https://www.raywenderlich.com/163857/whats-new-swift-4) does a great job covering the concepts in the Key-Value Coding section.

There are several different types of `KeyPath`. Commonly discussed types include [KeyPath](https://developer.apple.com/documentation/swift/keypath), [WritableKeyPath](https://developer.apple.com/documentation/swift/writablekeypath) and [ReferenceWritableKeyPath](https://developer.apple.com/documentation/swift/referencewritablekeypath). Here‚Äôs a summary of the different ones:

*   `KeyPath`: Specifies a root type on a specific value type.
*   `WritableKeyPath`: A KeyPath whose value you can also write to. It doesn‚Äôt work with classes.
*   `ReferenceWritableKeyPath`: A WritableKeyPath used for classes since classes are reference types.

A practical example of using a key path is in observing or capturing when a value changes on an object.

When you encounter a bug involving a third-party object, there is immense power in knowing when the state of that object changes. Beyond debugging, sometimes it just makes sense to hook up your custom code to respond when a value changes in a third-party object such as Apple‚Äôs UIImageView object. In [Design Patterns on iOS using Swift ‚Äì Part 2/2](https://www.raywenderlich.com/160653/design-patterns-ios-using-swift-part-22), you can learn more about the observer pattern in the section titled _Key-Value Observing (KVO)_.

However, there‚Äôs a use case here related to the kennels that fits right into our doggy world. Without this KVO power, how would dog catchers easily know when the kennels are available to put more dogs inside? Although many dog catchers would just love to take home each and every lost dog they find, it‚Äôs just not practical.

So dog catchers who just want to help dogs find their way home need to know when the kennels are available to place dogs into. The first step to making this possible is creating a key path. Open the _KennelsKeyPath_ page and, right after _‚òÜ Add KeyPath here_, add this:

```
let keyPath = \Kennels.available
```

This is how you create a `KeyPath`. You use a backslash on the type, followed by a chain of dot-separated properties ‚Äî in this case, one property deep. To use the `KeyPath` to observe changes to the `available` property, add the following code after _‚òÜ Add observe method call here_:

```
kennels.observe(keyPath) { kennels, change in
  if (kennels.available) {
    print("kennels are available")
  }
}
```

Click run and see the following message output to the console:

```
Kennels are available.
```

This approach can also be great for figuring out when a value has changed. Imagine being able to debug state changes to third-party objects! Nailing down when an item of interest changes can really keep you from barking up the wrong tree.

You‚Äôre done with the _KennelsKeyPath_ page!

## Understanding Dynamic Member Lookup

If you‚Äôve been keeping up with Swift 4.2 changes, you may have heard about _Dynamic Member Lookup_. If not, you‚Äôll go beyond just learning the concept here.

In this part of the tutorial, you‚Äôll see the power of _Dynamic Member Lookup_ in Swift by going over an example of how to create a real JSON DSL (Domain Specification Language) that allows the caller to use dot notation to access values from a JSON dictionary.

_Dynamic Member Lookup_ empowers the coder to use dot syntax for properties that don‚Äôt exist at compile time as opposed to messier ways. In short, you‚Äôre coding on faith that the members will exist at runtime and getting nice-to-read code in the process.

As mentioned in the [proposal for this feature](https://github.com/apple/swift-evolution/blob/master/proposals/0195-dynamic-member-lookup.md) and [associated conversations in the Swift community](https://forums.swift.org/t/se-0195-introduce-user-defined-dynamic-member-lookup-types/8658/10), this power offers great support for interoperability with other languages such as Python, database implementors and creating boilerplate-free wrappers around ‚Äústringly-typed‚Äù APIs such as CoreImage.

### Introducing @dynamicMemberLookup

Open the _DogCatcher_ page and review the code. In the playground, `Dog` represents the way a dog is running with `Direction`.

With the `dynamicMemberLookup` power, `directionOfMovement` and `moving` can be accessed even though those properties don‚Äôt explicitly exist. It‚Äôs time to make `Dog` dynamic.

### Adding dynamicMemberLookup to the Dog

The way to activate this dynamic power is through the use of the type attribute `@dynamicMemberLookup`.

Add the following code under _‚òÜ Add subscript method that returns a Direction here_:

```
subscript(dynamicMember member: String) -> Direction {
  if member == "moving" || member == "directionOfMovement" {
    // Here's where you would call the motion detection library
    // that's in another programming language such as Python
    return randomDirection()
  }
  return .motionless
}
```

Now add `dynamicMemberLookup` to `Dog` by uncommenting the line that‚Äôs marked _‚òÜ Uncomment this line_ above `Dog`.

You can now access a property named `directionOfMovement` or `moving`. Give it a try by adding the following on the line after _‚òÜ Use the dynamicMemberLookup feature for dynamicDog here_:

```
let directionOfMove: Dog.Direction = dynamicDog.directionOfMovement
print("Dog's direction of movement is \(directionOfMove).")

let movingDirection: Dog.Direction = dynamicDog.moving
print("Dog is moving \(movingDirection).")
```

Run the playground. With the values sometimes being _left_ and sometimes being _right_, the first two lines you should see are similar to:

```
Dog's direction of movement is left.
Dog is moving left.
```

### Overloading subscript(dynamicMember:)

Swift supports [overloading subscript declarations](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-ID379) with different return types. Try this out by adding a `subscript` that returns an `Int` right under _‚òÜ Add subscript method that returns an Int here_:

```
subscript(dynamicMember member: String) -> Int {
  if member == "speed" {
    // Here's where you would call the motion detection library
    // that's in another programming language such as Python.
    return 12
  }
  return 0
}
```

Now, you can access a property named `speed`. Speed to victory by adding the following under `movingDirection` that you added earlier:

```
let speed: Int = dynamicDog.speed
print("Dog's speed is \(speed).")
```

Run the playground. The output should contain:

```
Dog's speed is 12.
```

Pretty nice, huh? That‚Äôs a powerful feature that keeps the code looking nice even if you need to access other programming languages such as Python. As hinted at earlier, there‚Äôs a catch‚Ä¶

![](https://koenig-media.raywenderlich.com/uploads/2018/06/dog_ears_perk_up2_small.jpg)

‚ÄúA catch?‚Äù I‚Äôm all ears.

### Compiler and Code Completion Gone to the Dogs

In exchange for this dynamic runtime feature, you don‚Äôt get the benefits of compile-time checking of properties that depend on the `subscript(dynamicMember:)` functionality. Also, Xcode‚Äôs code completion feature can‚Äôt help you out either. However, the good news is that professional iOS developers read more code than they write.

The syntactic sugar that _Dynamic Member Lookup_ gives you is nothing to just throw away. It‚Äôs a nice feature that makes certain specific use cases of Swift and language interoperability bearable and enjoyable to view.

### Friendly Dog Catcher

The original proposal for _Dynamic Member Lookup_ addressed language interoperability, particularly with Python. However, that‚Äôs not the only circumstance where it‚Äôs useful.

To demonstrate a pure Swift use case, you‚Äôre going to work on the `JSONDogCatcher` code found in _DogCatcher.xcplaygroundpage_. It‚Äôs a simple struct with a few properties designed to handle `String`, `Int` and JSON dictionary. With a struct like this, you can create a `JSONDogCatcher` and ultimately go foraging for specific `String` or `Int` values.

_Traditional Subscript Method_  
A traditional way of drilling down into a JSON dictionary with a struct like this is to use a `subscript` method. The playground already contains a traditional `subscript` implementation. Accessing the `String` or `Int` values using the `subscript` method typically looks like the following and is also in the playground:

```
let json: [String: Any] = ["name": "Rover", "speed": 12,
                          "owner": ["name": "Ms. Simpson", "age": 36]]

let catcher = JSONDogCatcher.init(dictionary: json)

let messyName: String = catcher["owner"]?["name"]?.value() ?? ""
print("Owner's name extracted in a less readable way is \(messyName).")
```

Although you have to look past the brackets, quotes and question marks, this works.

Run the playground. You can now see the following:

```
Owner's name extracted in a less readable way is Ms. Simpson.
```

Although it works fine, it would be easier on the eyes to just use dot syntax. With _Dynamic Member Lookup_, you can drill down a multi-level JSON data structure.

_Adding dynamicMemberLookup to the Dog Catcher_  
Like `Dog`, it‚Äôs time to add the `dynamicMemberLookup` attribute to the `JSONDogCatcher` struct.

Add the following code right under _‚òÜ Add subscript(dynamicMember:) method that returns a JSONDogCatcher here_:

```
subscript(dynamicMember member: String) -> JSONDogCatcher? {
  return self[member]
}
```

The `subscript(dynamicMember:)` method calls the already existing `subscript` method but takes away the boilerplate code of using brackets and `String` keys. Now, uncomment the line which has _‚òÜ Uncomment this line_ above `JSONDogCatcher`:

```
@dynamicMemberLookup
struct JSONDogCatcher {
```

With that in place, you can use dot notation to get the dog‚Äôs speed and owner‚Äôs name. Try it out by adding the following right under _‚òÜ Use dot notation to get the owner‚Äôs name and speed through the catcher_:

```
let ownerName: String = catcher.owner?.name?.value() ?? ""
print("Owner's name is \(ownerName).")

let dogSpeed: Int = catcher.speed?.value() ?? 0
print("Dog's speed is \(dogSpeed).")
```

Run the playground. See the speed and the owner‚Äôs name in the console:

```
Owner's name is Ms. Simpson.
Dog's speed is 12.
```

Now that you have the owner‚Äôs name, the dog catcher can contact the owner and let her know her dog has been found!

What a happy ending! The dog and its owner are together again and the code looks cleaner. Through the power of dynamic Swift, this dynamic dog can go back to chasing bunnies in the backyard.

![](https://koenig-media.raywenderlich.com/uploads/2018/06/bunny_small.jpg)

Simpson‚Äôs dog loves chasing but not catching

## Where to Go From Here?

You can download the completed version of the project using the _Download Materials_ button at the top or bottom of this tutorial.

In this tutorial, you harnessed the dynamic power that Swift offers in version 4.2. You learned about Swift‚Äôs introspective reflection powers such as `Mirror`, customizing console output, hooking into _Key-Value Observing with KeyPaths_ and _Dynamic Member Lookup_.

With that dynamic smorgasbord, you can clearly see helpful information, have more readable code and hook into some powerful runtime capabilities for your app or general purpose framework and library.

Sniffing around [Apple‚Äôs documentation about Mirror](https://developer.apple.com/documentation/swift/mirror) and related items is a worthy endeavor. For more about _Key-Value Observing_, have a look at [Design Patterns on iOS using Swift](https://www.raywenderlich.com/160651/design-patterns-ios-using-swift-part-12). Be sure to check out the [What‚Äôs New in Swift 4.2?](https://www.raywenderlich.com/194066/whats-new-in-swift-4-2) to see more of what‚Äôs in Swift 4.2.

In regards to the _Dynamic Member Lookup_ Swift 4.2 feature, it doesn‚Äôt hurt to look at the Swift proposal [SE-0195: ‚ÄúIntroduce User-defined ‚ÄòDynamic Member Lookup‚Äô Types‚Äù](https://github.com/apple/swift-evolution/blob/master/proposals/0195-dynamic-member-lookup.md) that introduces the `dynamicMemberLookup` type attribute and potential use cases. On a related note, a Swift proposal to keep an eye on is the close cousin of _Dynamic Member Lookup_ called [SE-216: ‚ÄúIntroduce User-defined Dynamically ‚Äòcallable‚Äô Types](https://github.com/apple/swift-evolution/blob/master/proposals/0216-dynamic-callable.md) that introduces the `dynamicCallable` type attribute.

Have more to say or ask about the dynamic power of Swift? Join in on the forum discussion below!

> Â¶ÇÊûúÂèëÁé∞ËØëÊñáÂ≠òÂú®ÈîôËØØÊàñÂÖ∂‰ªñÈúÄË¶ÅÊîπËøõÁöÑÂú∞ÊñπÔºåÊ¨¢ËøéÂà∞ [ÊéòÈáëÁøªËØëËÆ°Âàí](https://github.com/xitu/gold-miner) ÂØπËØëÊñáËøõË°å‰øÆÊîπÂπ∂ PRÔºå‰πüÂèØËé∑ÂæóÁõ∏Â∫îÂ•ñÂä±ÁßØÂàÜ„ÄÇÊñáÁ´†ÂºÄÂ§¥ÁöÑ **Êú¨ÊñáÊ∞∏‰πÖÈìæÊé•** Âç≥‰∏∫Êú¨ÊñáÂú® GitHub ‰∏äÁöÑ MarkDown ÈìæÊé•„ÄÇ


---

> [ÊéòÈáëÁøªËØëËÆ°Âàí](https://github.com/xitu/gold-miner) ÊòØ‰∏Ä‰∏™ÁøªËØë‰ºòË¥®‰∫íËÅîÁΩëÊäÄÊúØÊñáÁ´†ÁöÑÁ§æÂå∫ÔºåÊñáÁ´†Êù•Ê∫ê‰∏∫ [ÊéòÈáë](https://juejin.im) ‰∏äÁöÑËã±ÊñáÂàÜ‰∫´ÊñáÁ´†„ÄÇÂÜÖÂÆπË¶ÜÁõñ [Android](https://github.com/xitu/gold-miner#android)„ÄÅ[iOS](https://github.com/xitu/gold-miner#ios)„ÄÅ[ÂâçÁ´Ø](https://github.com/xitu/gold-miner#ÂâçÁ´Ø)„ÄÅ[ÂêéÁ´Ø](https://github.com/xitu/gold-miner#ÂêéÁ´Ø)„ÄÅ[Âå∫ÂùóÈìæ](https://github.com/xitu/gold-miner#Âå∫ÂùóÈìæ)„ÄÅ[‰∫ßÂìÅ](https://github.com/xitu/gold-miner#‰∫ßÂìÅ)„ÄÅ[ËÆæËÆ°](https://github.com/xitu/gold-miner#ËÆæËÆ°)„ÄÅ[‰∫∫Â∑•Êô∫ËÉΩ](https://github.com/xitu/gold-miner#‰∫∫Â∑•Êô∫ËÉΩ)Á≠âÈ¢ÜÂüüÔºåÊÉ≥Ë¶ÅÊü•ÁúãÊõ¥Â§ö‰ºòË¥®ËØëÊñáËØ∑ÊåÅÁª≠ÂÖ≥Ê≥® [ÊéòÈáëÁøªËØëËÆ°Âàí](https://github.com/xitu/gold-miner)„ÄÅ[ÂÆòÊñπÂæÆÂçö](http://weibo.com/juejinfanyi)„ÄÅ[Áü•‰πé‰∏ìÊ†è](https://zhuanlan.zhihu.com/juejinfanyi)„ÄÇ
